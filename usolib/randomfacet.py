import random, itertools

from helpers import *


cache = {}

def randomfacet_analytic(uso, n, vertices=None, cube=None):
    """
    Return the expected runtime of RandomFacet on the USO generated by uso.

    Start positions of the algorithm are all elements of the vertices iterator. This allow easy splitting into
    separate tasks.
    Due to numerical stability concerns, the algorithm actually gives the sum of the runtimes on all vertices
    and all random choices. To get the expectation of a single execution, divide by N!*|vertices|
    """
    
    @memoize(cache)
    def RF(vertex, cube):
        #if n == 0:
        #if vertex == cube:
            #return 1, vertex

        total_runtime = 0
        sink = uso.find_sink(cube)
        for i in range(n):
            if cube[i] != "*":
                continue

            # recurse on the side where reference vertex is
            subcube = cube[:i] + vertex[i] + cube[i+1:]
            runtime, w = RF(vertex, subcube)
            total_runtime += runtime

            if sink[i] != w[i]:
                # sink not found in first recursive call, replace vertex with w ^ {i}
                # extremely inefficient xor
                w = w[:i] + ("1" if w[i] == "0" else "0") + w[i+1:]
                subcube = cube[:i] + w[i] + cube[i+1:]
                runtime, _ = RF(w, subcube)
                total_runtime += runtime

        return max(1, total_runtime), sink

    if cube is None:
        cube = "*" * n

    if vertices is None:
        # iterate over whole set of vertices
        vertices = generate_vertices(n)

    return sum(RF(vertex, cube)[0] for vertex in vertices)


def randomfacet_sample(uso, N, cube=None, vertex=None):
    """
    Return the runtime of 1 execution of RandomFacet on the USO generated by uso.
    """
    
    def RF(vertex, cube):
        if vertex == cube:
            return 1, vertex

        sink = uso.find_sink(cube)

        choices = [i for (i, dim) in enumerate(cube) if dim == "*"]
        i = random.choice(choices)

        # recurse on the side where the reference vertex is
        subcube = cube[:i] + vertex[i] + cube[i+1:]
        runtime, w = RF(vertex, subcube)
        total_runtime = runtime

        if sink[i] != w[i]:
            # sink not found in first recursive call, replace vertex with w ^ {i}
            w = w[:i] + ("1" if w[i] == "0" else "0") + w[i+1:]
            subcube = cube[:i] + w[i] + cube[i+1:]
            runtime, _ = RF(w, subcube)
            total_runtime += runtime

        return total_runtime, sink

    if cube is None:
        cube = "*" * N

    if vertex is None:
        # choose random vertex
        v = random.randint(0, 2**N-1)
        vertex = int_to_vertex(v, N)

    return RF(vertex, cube)[0]


