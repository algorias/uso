import itertools

from usolib.helpers import memoize

class SimpleFST(object):
    """
    An implementation of a simple finite state transducer.

    Inputs are words in {0,1}*
    Outputs are words in {+,-}*
    Subcubes are words in {0,1,*}*, where * means that dimension is spanned by the subcube.

    transition table is a dict that maps (state, input) to (state, output)

    Interpreting the input as a vertex of a hypercube, the output gives the orientation of the incident
    edges, where + means incoming. This induces a USO on any hypercube, as long as each state outputs + for one
    input and - for the other.
    """

    def __init__(self, table, start_state=0):
        self.table = table
        self.validate_table()
        self.start_state = start_state
        self.build_inverse_table()


    def validate_table(self):
        """ Check if table describes a simple FST."""
        states = set(state for (state, v) in self.table)

        for state in states:
            # make sure transitions exist and are valid
            nextstate, out0 = self.table[state, "0"]
            assert nextstate in states
            assert out0 in "+-"

            nextstate, out1 = self.table[state, "1"]
            assert nextstate in states
            assert out1 in "+-"

            # make sure state is either even or odd
            assert out0 != out1

    
    def build_inverse_table(self):
        """ Precalculate inverse state transition table to find + and - transitions easily."""
        states = set(state for (state, v) in self.table)
        self.inv_table = {}

        for state in states:
            nextstate, out = self.table[state, "0"]
            self.inv_table[state, out] = nextstate, "0"
            nextstate, out = self.table[state, "1"]
            self.inv_table[state, out] = nextstate, "1"


   
    def transduce(self, vertex):
        # implements the outmap of the USO generated by the automaton
        state = self.start_state
        for v in vertex:
            state, out = self.table[state, v]
            yield out


    def outmap(self, vertex, subcube):
        # NOTE: subcubes are described by words in {0,1,*}*
        # this method makes no attempt to validate that the vertex actually belongs to the subcube

        return [o for (o, s) in zip(self.transduce(vertex), subcube) if s == "*"]
    

    #@memoize()
    def find_sink(self, subcube):
        # find sink through structure of automaton, i.e. cheating
        res = []
        state = self.start_state
        for i, dim in enumerate(subcube):
            if dim == "*":
                state, v = self.inv_table[state, "+"]
            else:
                # jump
                state, _ = self.table[state, dim]
                v = dim

            res.append(v)
        return "".join(res)
            
